<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Magic Christmas - Final Clean</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #000000; font-family: 'Segoe UI', sans-serif; }
        #canvas-container { width: 100%; height: 100vh; display: block; }
        
        /* UI Center Vandiep */
        #ui-layer {
            position: absolute; bottom: 30px; width: 100%;
            text-align: center; pointer-events: none; z-index: 100;
        }
        
        /* Guide text Vandiep */
        .guide { 
            color: rgba(255, 255, 255, 0.6); 
            font-size: 13px; 
            margin-bottom: 20px; 
            text-shadow: 0 2px 4px black;
        }

        button {
            pointer-events: auto; cursor: pointer;
            background: linear-gradient(to bottom, #D32F2F, #8B0000); 
            color: #FFF; border: 2px solid #FFD700;
            padding: 15px 50px; border-radius: 30px; 
            font-weight: 800; font-size: 16px;
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.6);
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }

        /* Camera Preview Vandiep */
        #camera-preview {
            position: absolute; top: 15px; right: 15px;
            width: 120px; height: 90px;
            border: 2px solid rgba(255,0,0,0.5); 
            transform: scaleX(-1); opacity: 0.6; border-radius: 8px;
        }
        
        /* Vandiep */
        #copyright {
            position: absolute;
            bottom: 10px;
            right: 15px;
            color: rgba(255, 255, 255, 0.3);
            font-size: 12px;
            z-index: 100;
            font-family: sans-serif;
            pointer-events: none;
            font-style: italic;
        }

        #error-log { display: none; position: absolute; top: 0; left: 0; color: red; background: rgba(0,0,0,0.8); z-index: 999; padding: 10px; }
    </style>
</head>
<body>
    <div id="error-log"></div>
    
    <!-- UI Vandiep -->
    <div id="ui-layer">
        <!-- Vandiep -->
        <div class="guide">
            üñê <b>Open:</b> Explode &nbsp;|&nbsp; ü´∂ <b>Heart:</b> Love &nbsp;|&nbsp; ‚úä <b>Fist:</b> Tree
        </div>
        <button id="btnStart" onclick="startSystem()">START MAGIC</button>
    </div>

    <!-- Vandiep -->
    <div id="copyright">¬© by vandiep</div>

    <div id="canvas-container"></div>
    <video class="input_video" style="display:none"></video>
    <canvas id="camera-preview"></canvas>

    <script>
        // ==========================================
        // 1. RESOURCES CONFIG Vandiep
        // ==========================================
        // Kh·ªüi t·∫°o nh·∫°c n·ªÅn v√† c·∫•u h√¨nh loop
        const MUSIC_URL = "./audio.mp3";
        let bgMusic = new Audio(MUSIC_URL);
        bgMusic.loop = true; bgMusic.volume = 1.0;

        // Load c√°c texture ·∫£nh ƒë·ªÉ hi·ªÉn th·ªã trong 3D scene
        const loader = new THREE.TextureLoader();
        // T·∫°o m·∫£ng 10 ·∫£nh (image1.jpeg ƒë·∫øn image10.jpeg)
        const photoFiles = [];
        for(let i = 1; i <= 10; i++) {
            photoFiles.push(`./image${i}.jpeg`);
        }
        const photoTextures = [];
        photoFiles.forEach((f, i) => photoTextures[i] = loader.load(f));

        // T·∫°o texture t√πy ch·ªânh cho c√°c h·∫°t particle (v√†ng, ƒë·ªè, qu√†)
        function createCustomTexture(type) {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            const cx = 64, cy = 64; // T√¢m c·ªßa texture

            if (type === 'gold_glow') {
                // T·∫°o texture v√†ng ph√°t s√°ng v·ªõi gradient radial
                const grd = ctx.createRadialGradient(cx, cy, 0, cx, cy, 40);
                grd.addColorStop(0, '#FFFFFF'); // Tr·∫Øng ·ªü gi·ªØa
                grd.addColorStop(0.2, '#FFFFE0'); // V√†ng nh·∫°t
                grd.addColorStop(0.5, '#FFD700'); // V√†ng ƒë·∫≠m
                grd.addColorStop(1, 'rgba(0,0,0,0)'); // Trong su·ªët ·ªü ngo√†i
                ctx.fillStyle = grd; ctx.fillRect(0,0,128,128);

            } else if (type === 'red_light') {
                // T·∫°o texture ƒë·ªè ph√°t s√°ng
                const grd = ctx.createRadialGradient(cx, cy, 0, cx, cy, 50);
                grd.addColorStop(0, '#FFAAAA'); // ƒê·ªè nh·∫°t ·ªü gi·ªØa
                grd.addColorStop(0.3, '#FF0000'); // ƒê·ªè ƒë·∫≠m
                grd.addColorStop(1, 'rgba(0,0,0,0)'); // Trong su·ªët ·ªü ngo√†i
                ctx.fillStyle = grd; ctx.fillRect(0,0,128,128);

            } else if (type === 'gift_red') {
                // T·∫°o texture h·ªôp qu√† m√†u ƒë·ªè v·ªõi d√¢y v√†ng
                ctx.fillStyle = '#D32F2F'; ctx.fillRect(20, 20, 88, 88); // Th√¢n h·ªôp ƒë·ªè
                ctx.fillStyle = '#FFD700'; ctx.fillRect(54, 20, 20, 88); ctx.fillRect(20, 54, 88, 20); // D√¢y v√†ng
                ctx.strokeStyle = "rgba(0,0,0,0.3)"; ctx.lineWidth=2; ctx.strokeRect(20,20,88,88); // Vi·ªÅn
            }
            return new THREE.CanvasTexture(canvas);
        }

        const textures = {
            gold: createCustomTexture('gold_glow'),
            red: createCustomTexture('red_light'),
            gift: createCustomTexture('gift_red')
        };

        // ==========================================
        // 2. SYSTEM CONFIG Vandiep
        // ==========================================
        // C·∫•u h√¨nh s·ªë l∆∞·ª£ng h·∫°t v√† k√≠ch th∆∞·ªõc c√°c hi·ªáu ·ª©ng
        const CONFIG = {
            goldCount: 2000,        // S·ªë l∆∞·ª£ng h·∫°t v√†ng
            redCount: 300,          // S·ªë l∆∞·ª£ng h·∫°t ƒë·ªè
            giftCount: 150,         // S·ªë l∆∞·ª£ng h·∫°t qu√†
            explodeRadius: 65,      // B√°n k√≠nh khi n·ªï (explode)
            photoOrbitRadius: 25,   // B√°n k√≠nh qu·ªπ ƒë·∫°o c·ªßa ·∫£nh
            treeHeight: 70,         // Chi·ªÅu cao c√¢y th√¥ng
            treeBaseRadius: 35      // B√°n k√≠nh ƒë√°y c√¢y th√¥ng
        };

        // Bi·∫øn global cho Three.js scene
        let scene, camera, renderer;
        let groupGold, groupRed, groupGift; // C√°c nh√≥m h·∫°t particle
        let photoMeshes = [];    // M·∫£ng ch·ª©a c√°c mesh ·∫£nh
        let photoInitialPositions = []; // M·∫£ng ch·ª©a v·ªã tr√≠ ban ƒë·∫ßu ng·∫´u nhi√™n c·ªßa c√°c ·∫£nh trong h√¨nh c·∫ßu
        let titleMesh, starMesh, loveMesh; // C√°c decoration mesh
        
        // Tr·∫°ng th√°i hi·ªán t·∫°i c·ªßa h·ªá th·ªëng: TREE, HEART, EXPLODE, PHOTO
        let state = 'TREE'; 
        let selectedIndex = 0;   // Index c·ªßa ·∫£nh ƒë∆∞·ª£c ch·ªçn
        let handX = 0.5;         // V·ªã tr√≠ X c·ªßa b√†n tay (0-1) ƒë·ªÉ ƒëi·ªÅu khi·ªÉn rotation Y
        let handY = 0.5;         // V·ªã tr√≠ Y c·ªßa b√†n tay (0-1) ƒë·ªÉ ƒëi·ªÅu khi·ªÉn rotation X
        let handZoom = 1.0;      // Zoom level d·ª±a tr√™n kho·∫£ng c√°ch tay (0.5-1.5)

        // ==========================================
        // 3. THREE.JS SYSTEM Vandiep
        // ==========================================
        // Kh·ªüi t·∫°o h·ªá th·ªëng 3D v·ªõi Three.js
        function init3D() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.002); // Th√™m s∆∞∆°ng m√π ƒëen

            // T·∫°o camera perspective v·ªõi g√≥c nh√¨n 60 ƒë·ªô
            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.z = 100; // ƒê·∫∑t camera c√°ch xa 100 ƒë∆°n v·ªã

            // T·∫°o WebGL renderer v·ªõi antialiasing
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Gi·ªõi h·∫°n pixel ratio ƒë·ªÉ t·ªëi ∆∞u performance
            container.appendChild(renderer.domElement);

            // T·∫°o c√°c h·ªá th·ªëng h·∫°t particle v·ªõi s·ªë l∆∞·ª£ng v√† k√≠ch th∆∞·ªõc kh√°c nhau
            groupGold = createParticleSystem('gold', CONFIG.goldCount, 2.0);
            groupRed = createParticleSystem('red', CONFIG.redCount, 3.5); 
            groupGift = createParticleSystem('gift', CONFIG.giftCount, 3.0); 

            // T·∫°o ·∫£nh v√† c√°c decoration (title, star, love text)
            createPhotos();
            createDecorations();
            animate(); // B·∫Øt ƒë·∫ßu animation loop
        }

        // T·∫°o h·ªá th·ªëng particle v·ªõi c√°c v·ªã tr√≠ target cho c√°c tr·∫°ng th√°i kh√°c nhau
        function createParticleSystem(type, count, size) {
            const pPositions = [];      // V·ªã tr√≠ hi·ªán t·∫°i c·ªßa c√°c h·∫°t
            const pExplodeTargets = []; // V·ªã tr√≠ target khi ·ªü tr·∫°ng th√°i EXPLODE
            const pTreeTargets = [];    // V·ªã tr√≠ target khi ·ªü tr·∫°ng th√°i TREE
            const pHeartTargets = [];   // V·ªã tr√≠ target khi ·ªü tr·∫°ng th√°i HEART
            const sizes = [];           // K√≠ch th∆∞·ªõc c·ªßa t·ª´ng h·∫°t
            const phases = [];          // Phase ƒë·ªÉ t·∫°o hi·ªáu ·ª©ng nh·∫•p nh√°y
            
            for(let i=0; i<count; i++) {
                // --- TREE: T·∫°o h√¨nh d·∫°ng c√¢y th√¥ng (h√¨nh n√≥n) ---
                const h = Math.random() * CONFIG.treeHeight; // Chi·ªÅu cao ng·∫´u nhi√™n
                const y = h - CONFIG.treeHeight / 2; // ƒêi·ªÅu ch·ªânh ƒë·ªÉ cƒÉn gi·ªØa
                // H·∫°t v√†ng ph√¢n b·ªë ƒë·ªÅu h∆°n, h·∫°t ƒë·ªè/qu√† t·∫≠p trung ·ªü ngo√†i
                let radiusRatio = (type === 'gold') ? Math.sqrt(Math.random()) : 0.9 + Math.random()*0.1;
                // B√°n k√≠nh gi·∫£m d·∫ßn t·ª´ ƒë√°y l√™n ƒë·ªânh (t·∫°o h√¨nh n√≥n)
                const maxR = (1 - (h / CONFIG.treeHeight)) * CONFIG.treeBaseRadius;
                const r = maxR * radiusRatio; 
                const theta = Math.random() * Math.PI * 2; // G√≥c ng·∫´u nhi√™n
                pTreeTargets.push(r * Math.cos(theta), y, r * Math.sin(theta));

                // --- EXPLODE: Ph√¢n b·ªë h·∫°t trong h√¨nh c·∫ßu ---
                const u = Math.random();
                const v = Math.random();
                // S·ª≠ d·ª•ng spherical coordinates ƒë·ªÉ ph√¢n b·ªë ƒë·ªÅu trong kh√¥ng gian 3D
                const phi = Math.acos(2 * v - 1); // G√≥c t·ª´ tr·ª•c Z
                const lam = 2 * Math.PI * u;      // G√≥c quanh tr·ª•c Z
                let radMult = (type === 'gift') ? 1.2 : 1.0; // Qu√† n·ªï xa h∆°n m·ªôt ch√∫t
                // D√πng cube root ƒë·ªÉ ph√¢n b·ªë ƒë·ªÅu h∆°n trong th·ªÉ t√≠ch
                const rad = CONFIG.explodeRadius * Math.cbrt(Math.random()) * radMult;
                pExplodeTargets.push(rad * Math.sin(phi) * Math.cos(lam), rad * Math.sin(phi) * Math.sin(lam), rad * Math.cos(phi));

                // --- SOFT HEART: T·∫°o h√¨nh tr√°i tim m·ªÅm m·∫°i ---
                const tHeart = Math.random() * Math.PI * 2; // Tham s·ªë cho ph∆∞∆°ng tr√¨nh tr√°i tim
                // Ph∆∞∆°ng tr√¨nh parametric c·ªßa tr√°i tim
                let hx = 16 * Math.pow(Math.sin(tHeart), 3);
                let hy = 13 * Math.cos(tHeart) - 5 * Math.cos(2*tHeart) - 2 * Math.cos(3*tHeart) - Math.cos(4*tHeart);
                
                // L√†m m·ªÅm v√† ƒëi·ªÅn ƒë·∫ßy b√™n trong tr√°i tim
                const rFill = Math.pow(Math.random(), 0.3); // Random nh∆∞ng t·∫≠p trung g·∫ßn 1
                hx *= rFill; hy *= rFill;
                let hz = (Math.random() - 0.5) * 8 * rFill; // ƒê·ªô s√¢u ng·∫´u nhi√™n
                
                // Th√™m noise ƒë·ªÉ t·ª± nhi√™n h∆°n
                const noise = 1.0;
                hx += (Math.random() - 0.5) * noise;
                hy += (Math.random() - 0.5) * noise;
                hz += (Math.random() - 0.5) * noise;

                const scaleH = 2.2; // Scale ƒë·ªÉ tr√°i tim l·ªõn h∆°n
                pHeartTargets.push(hx * scaleH, hy * scaleH + 5, hz); // +5 ƒë·ªÉ n√¢ng l√™n m·ªôt ch√∫t

                // --- INIT: Kh·ªüi t·∫°o v·ªã tr√≠ ban ƒë·∫ßu (b·∫Øt ƒë·∫ßu t·ª´ h√¨nh c√¢y) ---
                pPositions.push(pTreeTargets[i*3], pTreeTargets[i*3+1], pTreeTargets[i*3+2]);
                sizes.push(size);
                phases.push(Math.random() * Math.PI * 2); // Phase ng·∫´u nhi√™n cho animation
            }

            // T·∫°o BufferGeometry ƒë·ªÉ l∆∞u tr·ªØ d·ªØ li·ªáu c·ªßa c√°c h·∫°t
            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pPositions, 3)); // V·ªã tr√≠ x,y,z
            geo.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1)); // K√≠ch th∆∞·ªõc
            
            // Kh·ªüi t·∫°o m√†u s·∫Øc cho c√°c h·∫°t d·ª±a tr√™n lo·∫°i
            const colors = new Float32Array(count * 3); // RGB cho m·ªói h·∫°t
            const baseColor = new THREE.Color();
            if(type === 'gold') baseColor.setHex(0xFFD700);      // V√†ng
            else if(type === 'red') baseColor.setHex(0xFF0000);  // ƒê·ªè
            else baseColor.setHex(0xFFFFFF);                      // Tr·∫Øng (cho gift)

            // G√°n m√†u cho t·∫•t c·∫£ c√°c h·∫°t
            for(let i=0; i<count; i++) {
                colors[i*3] = baseColor.r;
                colors[i*3+1] = baseColor.g;
                colors[i*3+2] = baseColor.b;
            }
            geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            // L∆∞u c√°c target positions v√† metadata v√†o userData ƒë·ªÉ d√πng sau
            geo.userData = { 
                tree: pTreeTargets, explode: pExplodeTargets, heart: pHeartTargets, 
                phases: phases, baseColor: baseColor, baseSize: size
            };

            // T·∫°o material cho c√°c h·∫°t
            const mat = new THREE.PointsMaterial({
                size: size,
                map: textures[type], // Texture t√πy ch·ªânh
                transparent: true, opacity: 1.0,
                vertexColors: true, // S·ª≠ d·ª•ng m√†u t·ª´ vertex
                blending: (type === 'gift') ? THREE.NormalBlending : THREE.AdditiveBlending, // Gift d√πng normal, c√≤n l·∫°i additive ƒë·ªÉ s√°ng h∆°n
                depthWrite: false, // Kh√¥ng ghi depth ƒë·ªÉ tr√°nh artifact
                sizeAttenuation: true // K√≠ch th∆∞·ªõc gi·∫£m theo kho·∫£ng c√°ch
            });

            const points = new THREE.Points(geo, mat);
            scene.add(points);
            return points;
        }

        // T·∫°o c√°c mesh ·∫£nh v·ªõi vi·ªÅn v√†ng v√† v·ªã tr√≠ ban ƒë·∫ßu ph√¢n b·ªë ƒë·ªÅu tr√™n b·ªÅ m·∫∑t h√¨nh c·∫ßu
        function createPhotos() {
            const geo = new THREE.PlaneGeometry(8, 8); // Geometry cho ·∫£nh
            const borderGeo = new THREE.PlaneGeometry(9, 9); // Geometry cho vi·ªÅn (l·ªõn h∆°n 1 ƒë∆°n v·ªã)
            const borderMat = new THREE.MeshBasicMaterial({ color: 0xFFD700 }); // Vi·ªÅn v√†ng

            // T·∫°o ·∫£nh v·ªõi v·ªã tr√≠ ph√¢n b·ªë ƒë·ªÅu tr√™n b·ªÅ m·∫∑t h√¨nh c·∫ßu
            const photoCount = photoFiles.length;
            const radius = CONFIG.photoOrbitRadius; // B√°n k√≠nh c·ªë ƒë·ªãnh cho t·∫•t c·∫£ ·∫£nh
            
            // S·ª≠ d·ª•ng Fibonacci sphere ƒë·ªÉ ph√¢n b·ªë ƒë·ªÅu tr√™n b·ªÅ m·∫∑t h√¨nh c·∫ßu
            const goldenAngle = Math.PI * (3 - Math.sqrt(5)); // Golden angle in radians
            
            for(let i=0; i<photoCount; i++) {
                const mat = new THREE.MeshBasicMaterial({ map: photoTextures[i], side: THREE.DoubleSide });
                const mesh = new THREE.Mesh(geo, mat);
                const border = new THREE.Mesh(borderGeo, borderMat);
                border.position.z = -0.1; // ƒê·∫∑t vi·ªÅn ph√≠a sau m·ªôt ch√∫t
                mesh.add(border); // G·∫Øn vi·ªÅn v√†o mesh
                mesh.visible = false; mesh.scale.set(0,0,0); // ·∫®n ban ƒë·∫ßu
                scene.add(mesh);
                photoMeshes.push(mesh);
                
                // Fibonacci sphere algorithm ƒë·ªÉ ph√¢n b·ªë ƒë·ªÅu tr√™n b·ªÅ m·∫∑t h√¨nh c·∫ßu
                const y = 1 - (i / (photoCount - 1)) * 2; // y t·ª´ 1 ƒë·∫øn -1
                const r = Math.sqrt(1 - y * y); // B√°n k√≠nh t·∫°i y
                const theta = goldenAngle * i; // G√≥c xoay quanh tr·ª•c Y
                
                // Chuy·ªÉn t·ª´ spherical coordinates sang Cartesian coordinates
                const x = Math.cos(theta) * r * radius;
                const z = Math.sin(theta) * r * radius;
                const yPos = y * radius;
                
                // L∆∞u v·ªã tr√≠ ban ƒë·∫ßu (s·∫Ω ƒë∆∞·ª£c xoay theo tay sau n√†y)
                photoInitialPositions.push(new THREE.Vector3(x, yPos, z));
            }
        }

        function createDecorations() {
            // MERRY CHRISTMAS Vandiep
            const canvas = document.createElement('canvas');
            canvas.width = 1024; canvas.height = 256;
            const ctx = canvas.getContext('2d');
            ctx.font = 'bold italic 90px "Times New Roman"';
            ctx.fillStyle = '#FFD700'; ctx.textAlign = 'center';
            ctx.shadowColor = "#FF0000"; ctx.shadowBlur = 40; 
            ctx.fillText("MERRY CHRISTMAS", 512, 130);
            const tex = new THREE.CanvasTexture(canvas);
            const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true, blending: THREE.AdditiveBlending });
            titleMesh = new THREE.Mesh(new THREE.PlaneGeometry(60, 15), mat);
            titleMesh.position.set(0, 50, 0);
            scene.add(titleMesh);

            // STAR Vandiep
            const starCanvas = document.createElement('canvas');
            starCanvas.width = 128; starCanvas.height = 128;
            const sCtx = starCanvas.getContext('2d');
            sCtx.fillStyle = "#FFFF00"; sCtx.shadowColor="#FFF"; sCtx.shadowBlur=20;
            sCtx.beginPath();
            const cx=64, cy=64, outer=50, inner=20;
            for(let i=0; i<5; i++){
                sCtx.lineTo(cx + Math.cos((18+i*72)/180*Math.PI)*outer, cy - Math.sin((18+i*72)/180*Math.PI)*outer);
                sCtx.lineTo(cx + Math.cos((54+i*72)/180*Math.PI)*inner, cy - Math.sin((54+i*72)/180*Math.PI)*inner);
            }
            sCtx.closePath(); sCtx.fill();
            const starTex = new THREE.CanvasTexture(starCanvas);
            const starMat = new THREE.MeshBasicMaterial({ map: starTex, transparent: true, blending: THREE.AdditiveBlending });
            starMesh = new THREE.Mesh(new THREE.PlaneGeometry(12, 12), starMat);
            starMesh.position.set(0, CONFIG.treeHeight/2 + 2, 0);
            scene.add(starMesh);

            // I LOVE YOU TEXT Vandiep
            const loveCanvas = document.createElement('canvas');
            loveCanvas.width = 1024; loveCanvas.height = 256;
            const lCtx = loveCanvas.getContext('2d');
            lCtx.font = 'bold 120px "Segoe UI", sans-serif';
            lCtx.fillStyle = '#FF69B4'; lCtx.textAlign = 'center';
            lCtx.shadowColor = "#FF1493"; lCtx.shadowBlur = 40; 
            lCtx.fillText("I LOVE YOU ‚ù§Ô∏è", 512, 130);
            const loveTex = new THREE.CanvasTexture(loveCanvas);
            const loveMat = new THREE.MeshBasicMaterial({ map: loveTex, transparent: true, blending: THREE.AdditiveBlending });
            loveMesh = new THREE.Mesh(new THREE.PlaneGeometry(70, 18), loveMat);
            loveMesh.position.set(0, 0, 20);
            loveMesh.visible = false;
            scene.add(loveMesh);
        }

        // C·∫≠p nh·∫≠t v·ªã tr√≠, m√†u s·∫Øc v√† k√≠ch th∆∞·ªõc c·ªßa c√°c h·∫°t d·ª±a tr√™n tr·∫°ng th√°i
        function updateParticleGroup(group, type, targetState, speed, handRotX, handRotY, time) {
            const positions = group.geometry.attributes.position.array; // M·∫£ng v·ªã tr√≠ hi·ªán t·∫°i
            const sizes = group.geometry.attributes.size.array;         // M·∫£ng k√≠ch th∆∞·ªõc
            const colors = group.geometry.attributes.color.array;        // M·∫£ng m√†u s·∫Øc
            const phases = group.geometry.userData.phases;               // Phase cho animation
            const baseColor = group.geometry.userData.baseColor;         // M√†u c∆° b·∫£n
            const baseSize = group.geometry.userData.baseSize;           // K√≠ch th∆∞·ªõc c∆° b·∫£n
            
            // X√°c ƒë·ªãnh target positions d·ª±a tr√™n tr·∫°ng th√°i
            const targetKey = (targetState === 'TREE') ? 'tree' : (targetState === 'HEART' ? 'heart' : 'explode');
            const targets = group.geometry.userData[(targetState === 'PHOTO') ? 'explode' : targetKey];

            // 1. Di chuy·ªÉn c√°c h·∫°t v·ªÅ v·ªã tr√≠ target v·ªõi t·ªëc ƒë·ªô speed (interpolation)
            for(let i=0; i<positions.length; i++) {
                positions[i] += (targets[i] - positions[i]) * speed; // Linear interpolation
            }
            group.geometry.attributes.position.needsUpdate = true;
            
            // 2. C·∫≠p nh·∫≠t m√†u s·∫Øc v√† k√≠ch th∆∞·ªõc d·ª±a tr√™n tr·∫°ng th√°i
            const count = positions.length / 3; // S·ªë l∆∞·ª£ng h·∫°t (m·ªói h·∫°t c√≥ 3 gi√° tr·ªã x,y,z)
            
            if (targetState === 'TREE') {
                // Tr·∫°ng th√°i c√¢y th√¥ng: xoay ch·∫≠m v√† nh·∫•p nh√°y
                // Reset rotation X v·ªÅ 0 ƒë·ªÉ c√¢y kh√¥ng b·ªã nghi√™ng (smooth transition)
                group.rotation.x += (0 - group.rotation.x) * 0.1; // Smooth v·ªÅ 0
                group.rotation.y += 0.003; // Xoay c√¢y t·ª´ t·ª´ (ch·ªâ xoay ngang)
                
                for(let i=0; i<count; i++) {
                    sizes[i] = baseSize;
                    let brightness = 1.0;
                    if(type === 'red') {
                        // H·∫°t ƒë·ªè nh·∫•p nh√°y ch·∫≠m (t·∫ßn s·ªë 3)
                        brightness = 0.5 + 0.5 * Math.sin(time * 3 + phases[i]);
                    } else if(type === 'gold') {
                        // H·∫°t v√†ng nh·∫•p nh√°y nhanh (t·∫ßn s·ªë 10)
                        brightness = 0.8 + 0.4 * Math.sin(time * 10 + phases[i]);
                    }
                    // √Åp d·ª•ng brightness v√†o m√†u
                    colors[i*3]   = baseColor.r * brightness;
                    colors[i*3+1] = baseColor.g * brightness;
                    colors[i*3+2] = baseColor.b * brightness;
                }
                group.geometry.attributes.color.needsUpdate = true;
                group.geometry.attributes.size.needsUpdate = true;

            } else if (targetState === 'HEART') {
                // Tr·∫°ng th√°i tr√°i tim: ƒë·∫≠p nh·ªãp v√† ch·ªâ hi·ªÉn th·ªã 1/3 h·∫°t
                // Reset c·∫£ rotation X v√† Y v·ªÅ 0 (smooth transition)
                group.rotation.x += (0 - group.rotation.x) * 0.1; // Smooth v·ªÅ 0
                group.rotation.y += (0 - group.rotation.y) * 0.1; // Smooth v·ªÅ 0
                const beatScale = 1 + Math.abs(Math.sin(time * 3)) * 0.15; // Scale ƒë·∫≠p nh·ªãp
                group.scale.set(beatScale, beatScale, beatScale);

                // Ch·ªâ hi·ªÉn th·ªã m·ªói h·∫°t th·ª© 3 ƒë·ªÉ t·∫°o hi·ªáu ·ª©ng th∆∞a th·ªõt
                for(let i=0; i<count; i++) {
                    colors[i*3] = baseColor.r; colors[i*3+1] = baseColor.g; colors[i*3+2] = baseColor.b;
                    if (i % 3 === 0) sizes[i] = baseSize; // Ch·ªâ h·∫°t th·ª© 0, 3, 6, 9... hi·ªÉn th·ªã
                    else sizes[i] = 0; // C√°c h·∫°t kh√°c ·∫©n ƒëi
                }
                group.geometry.attributes.color.needsUpdate = true;
                group.geometry.attributes.size.needsUpdate = true;

            } else {
                // Tr·∫°ng th√°i EXPLODE: xoay ƒëa h∆∞·ªõng 3D theo tay v√† nh·∫•p nh√°y nhanh
                group.scale.set(1,1,1); // Reset scale
                // Xoay theo c·∫£ tr·ª•c X v√† Y d·ª±a tr√™n v·ªã tr√≠ tay (spherical rotation)
                group.rotation.x += (handRotX - group.rotation.x) * 0.1; // Xoay theo tr·ª•c X (smooth)
                group.rotation.y += (handRotY - group.rotation.y) * 0.1; // Xoay theo tr·ª•c Y (smooth)

                // C·∫≠p nh·∫≠t size v√† color v·ªõi hi·ªáu ·ª©ng nh·∫•p nh√°y
                for(let i=0; i<count; i++) {
                    sizes[i] = baseSize;
                    let brightness = 1.0;
                    if(type === 'gold' || type === 'red') {
                        // Nh·∫•p nh√°y r·∫•t nhanh (t·∫ßn s·ªë 12)
                        brightness = 0.8 + 0.5 * Math.sin(time * 12 + phases[i]);
                    }
                    colors[i*3]   = baseColor.r * brightness;
                    colors[i*3+1] = baseColor.g * brightness;
                    colors[i*3+2] = baseColor.b * brightness;
                }
                group.geometry.attributes.size.needsUpdate = true;
                group.geometry.attributes.color.needsUpdate = true;
            }
        }

        // Animation loop ch√≠nh - ch·∫°y m·ªói frame
        function animate() {
            requestAnimationFrame(animate); // L·∫∑p l·∫°i animation
            const time = Date.now() * 0.001; // Th·ªùi gian t√≠nh b·∫±ng gi√¢y
            const speed = 0.08; // T·ªëc ƒë·ªô di chuy·ªÉn c·ªßa h·∫°t (interpolation speed)
            
            // Chuy·ªÉn v·ªã tr√≠ tay th√†nh g√≥c xoay 3D (spherical coordinates)
            // handX (0-1) -> rotation Y: -2œÄ ƒë·∫øn 2œÄ (xoay ngang, cho ph√©p 2 v√≤ng ƒë·ªÉ xem h·∫øt ·∫£nh)
            const handRotY = (handX - 0.5) * Math.PI * 4; 
            // handY (0-1) -> rotation X: -œÄ/2 ƒë·∫øn œÄ/2 (xoay d·ªçc, gi·ªõi h·∫°n ƒë·ªÉ tr√°nh l·ªôn ng∆∞·ª£c)
            const handRotX = (handY - 0.5) * Math.PI;

            // C·∫≠p nh·∫≠t t·∫•t c·∫£ c√°c nh√≥m h·∫°t v·ªõi rotation 3D
            updateParticleGroup(groupGold, 'gold', state, speed, handRotX, handRotY, time);
            updateParticleGroup(groupRed, 'red', state, speed, handRotX, handRotY, time);
            updateParticleGroup(groupGift, 'gift', state, speed, handRotX, handRotY, time);

            // ƒê·∫£m b·∫£o texture ƒë√£ load cho c√°c ·∫£nh
            photoMeshes.forEach((mesh, i) => {
                if(!mesh.material.map && photoTextures[i]) {
                    mesh.material.map = photoTextures[i]; mesh.material.needsUpdate = true;
                }
            });

            // X·ª≠ l√Ω UI v√† animation d·ª±a tr√™n tr·∫°ng th√°i hi·ªán t·∫°i
            if (state === 'TREE') {
                // Hi·ªÉn th·ªã title v√† ng√¥i sao, ·∫©n love text v√† ·∫£nh
                titleMesh.visible = true; starMesh.visible = true; loveMesh.visible = false;
                titleMesh.scale.lerp(new THREE.Vector3(1,1,1), 0.1); // Scale v·ªÅ k√≠ch th∆∞·ªõc b√¨nh th∆∞·ªùng
                starMesh.rotation.z -= 0.02; // Xoay ng√¥i sao
                starMesh.material.opacity = 0.7 + 0.3*Math.sin(time*5); // Nh·∫•p nh√°y opacity
                photoMeshes.forEach(m => { m.scale.lerp(new THREE.Vector3(0,0,0), 0.1); m.visible = false; });
                // Reset camera v·ªÅ v·ªã tr√≠ m·∫∑c ƒë·ªãnh khi kh√¥ng ·ªü EXPLODE
                const baseCameraZ = 100;
                camera.position.z += (baseCameraZ - camera.position.z) * 0.1;

            } else if (state === 'HEART') {
                // Hi·ªÉn th·ªã love text, ·∫©n title v√† star
                titleMesh.visible = false; starMesh.visible = false; loveMesh.visible = true;
                photoMeshes.forEach(m => { m.visible = false; });
                const s = 1 + Math.abs(Math.sin(time*3))*0.1; // Scale ƒë·∫≠p nh·ªãp
                loveMesh.scale.set(s,s,1);
                // Reset camera v·ªÅ v·ªã tr√≠ m·∫∑c ƒë·ªãnh khi kh√¥ng ·ªü EXPLODE
                const baseCameraZ = 100;
                camera.position.z += (baseCameraZ - camera.position.z) * 0.1;

            } else if (state === 'EXPLODE') {
                // Hi·ªÉn th·ªã ·∫£nh ph√¢n b·ªë trong h√¨nh c·∫ßu v√† xoay ƒëa h∆∞·ªõng theo tay
                titleMesh.visible = false; starMesh.visible = false; loveMesh.visible = false;
                
                // T√≠nh rotation t·ª´ v·ªã tr√≠ tay (tƒÉng ph·∫°m vi ƒë·ªÉ xoay 2 v√≤ng)
                const handRotY = (handX - 0.5) * Math.PI * 4; // Rotation Y (xoay ngang, cho ph√©p 2 v√≤ng)
                const handRotX = (handY - 0.5) * Math.PI; // Rotation X (xoay d·ªçc)
                
                // √Åp d·ª•ng zoom cho camera d·ª±a tr√™n kho·∫£ng c√°ch tay
                const baseCameraZ = 100; // V·ªã tr√≠ camera m·∫∑c ƒë·ªãnh
                const targetZ = baseCameraZ / handZoom; // Zoom in khi handZoom > 1, zoom out khi < 1
                camera.position.z += (targetZ - camera.position.z) * 0.1; // Smooth zoom
                
                // T·∫°o rotation matrix ƒë·ªÉ xoay c√°c v·ªã tr√≠ ban ƒë·∫ßu
                const rotationMatrix = new THREE.Matrix4();
                rotationMatrix.makeRotationX(handRotX); // Xoay theo tr·ª•c X tr∆∞·ªõc
                rotationMatrix.multiply(new THREE.Matrix4().makeRotationY(handRotY)); // Sau ƒë√≥ xoay theo tr·ª•c Y
                
                let bestIdx = 0; let maxZ = -999; // T√¨m ·∫£nh g·∫ßn camera nh·∫•t (z l·ªõn nh·∫•t)
                
                photoMeshes.forEach((mesh, i) => {
                    mesh.visible = true;
                    
                    // L·∫•y v·ªã tr√≠ ban ƒë·∫ßu v√† √°p d·ª•ng rotation
                    const initialPos = photoInitialPositions[i].clone();
                    initialPos.applyMatrix4(rotationMatrix); // Xoay v·ªã tr√≠ theo rotation matrix
                    
                    // Th√™m m·ªôt ch√∫t animation nh·∫π (di chuy·ªÉn l√™n xu·ªëng)
                    const animY = Math.sin(time * 0.5 + i) * 2; // Animation nh·∫π
                    const finalPos = new THREE.Vector3(initialPos.x, initialPos.y + animY, initialPos.z);
                    
                    mesh.position.lerp(finalPos, 0.1); // Smooth movement
                    mesh.lookAt(camera.position); // Lu√¥n h∆∞·ªõng v·ªÅ camera
                    
                    // T√¨m ·∫£nh g·∫ßn nh·∫•t (z l·ªõn nh·∫•t)
                    if (finalPos.z > maxZ) { maxZ = finalPos.z; bestIdx = i; }
                    
                    // Scale l·ªõn h∆°n khi ·ªü ph√≠a tr∆∞·ªõc (z > 5)
                    if (finalPos.z > 5) { 
                        const ds = 1.0 + (finalPos.z/CONFIG.photoOrbitRadius)*0.8; 
                        mesh.scale.lerp(new THREE.Vector3(ds, ds, ds), 0.1);
                    } else {
                        mesh.scale.lerp(new THREE.Vector3(0.6, 0.6, 0.6), 0.1);
                    }
                });
                selectedIndex = bestIdx; // L∆∞u index c·ªßa ·∫£nh ƒë∆∞·ª£c ch·ªçn

            } else if (state === 'PHOTO') {
                // Hi·ªÉn th·ªã ·∫£nh ƒë∆∞·ª£c ch·ªçn ·ªü gi·ªØa m√†n h√¨nh, ph√≥ng to
                loveMesh.visible = false;
                photoMeshes.forEach((mesh, i) => {
                    if (i === selectedIndex) {
                        // Di chuy·ªÉn ·∫£nh ƒë∆∞·ª£c ch·ªçn ra gi·ªØa v√† ph√≥ng to
                        mesh.position.lerp(new THREE.Vector3(0, 0, 60), 0.1);
                        mesh.scale.lerp(new THREE.Vector3(5, 5, 5), 0.1);
                        mesh.lookAt(camera.position); mesh.rotation.z = 0; // H∆∞·ªõng v·ªÅ camera
                    } else {
                        // ·∫®n c√°c ·∫£nh kh√°c
                        mesh.scale.lerp(new THREE.Vector3(0,0,0), 0.1);
                    }
                });
            }
            renderer.render(scene, camera); // Render frame
        }

        // H√†m kh·ªüi ƒë·ªông h·ªá th·ªëng: b·∫Øt ƒë·∫ßu camera v√† nh·∫≠n di·ªán c·ª≠ ch·ªâ tay
        function startSystem() {
            document.getElementById('btnStart').style.display = 'none'; // ·∫®n n√∫t Start
            bgMusic.play().catch(e => console.log(e)); // Ph√°t nh·∫°c n·ªÅn
            init3D(); // Kh·ªüi t·∫°o scene 3D

            // L·∫•y video element v√† canvas ƒë·ªÉ hi·ªÉn th·ªã preview camera
            const video = document.getElementsByClassName('input_video')[0];
            const canvas = document.getElementById('camera-preview');
            const ctx = canvas.getContext('2d');
            
            // Kh·ªüi t·∫°o MediaPipe Hands ƒë·ªÉ nh·∫≠n di·ªán c·ª≠ ch·ªâ tay
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            // C·∫•u h√¨nh: t·ªëi ƒëa 2 tay, ƒë·ªô ph·ª©c t·∫°p trung b√¨nh, ng∆∞·ª°ng confidence 0.5
            hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });

            // Callback x·ª≠ l√Ω k·∫øt qu·∫£ nh·∫≠n di·ªán t·ª´ MediaPipe
            hands.onResults(results => {
                // V·∫Ω preview camera l√™n canvas (k√≠ch th∆∞·ªõc nh·ªè 100x75)
                ctx.clearRect(0,0,100,75); ctx.drawImage(results.image, 0, 0, 100, 75);

                // --- LOGIC NH·∫¨N DI·ªÜN C·ª¨ CH·ªà TAY ---
                
                // Ki·ªÉm tra c·ª≠ ch·ªâ HEART: 2 tay ch·∫°m nhau
                if (results.multiHandLandmarks.length === 2) {
                    const h1 = results.multiHandLandmarks[0]; // B√†n tay th·ª© nh·∫•t
                    const h2 = results.multiHandLandmarks[1]; // B√†n tay th·ª© hai
                    // T√≠nh kho·∫£ng c√°ch gi·ªØa 2 ng√≥n tr·ªè (landmark 8)
                    const distIndex = Math.hypot(h1[8].x - h2[8].x, h1[8].y - h2[8].y);
                    // T√≠nh kho·∫£ng c√°ch gi·ªØa 2 ng√≥n c√°i (landmark 4)
                    const distThumb = Math.hypot(h1[4].x - h2[4].x, h1[4].y - h2[4].y);
                    // N·∫øu c·∫£ 2 kho·∫£ng c√°ch ƒë·ªÅu nh·ªè (< 0.15) => c·ª≠ ch·ªâ HEART
                    if (distIndex < 0.15 && distThumb < 0.15) {
                        state = 'HEART'; return;
                    }
                }

                // X·ª≠ l√Ω c·ª≠ ch·ªâ v·ªõi 1 tay
                if(results.multiHandLandmarks.length > 0) {
                    const lm = results.multiHandLandmarks[0]; // L·∫•y b√†n tay ƒë·∫ßu ti√™n
                    handX = lm[9].x; // L∆∞u v·ªã tr√≠ X c·ªßa ƒëi·ªÉm gi·ªØa b√†n tay (landmark 9) ƒë·ªÉ ƒëi·ªÅu khi·ªÉn rotation Y
                    handY = lm[9].y; // L∆∞u v·ªã tr√≠ Y c·ªßa ƒëi·ªÉm gi·ªØa b√†n tay (landmark 9) ƒë·ªÉ ƒëi·ªÅu khi·ªÉn rotation X
                    
                    // T√≠nh zoom d·ª±a tr√™n ƒë·ªô x√≤e ng√≥n tay (kho·∫£ng c√°ch gi·ªØa c√°c ƒë·∫ßu ng√≥n)
                    // S·ª≠ d·ª•ng kho·∫£ng c√°ch gi·ªØa c√°c ƒë·∫ßu ng√≥n ƒë·ªÉ tr√°nh tr√πng v·ªõi action n·∫Øm tay (TREE)
                    const tips = [8,12,16,20]; // Index, Middle, Ring, Pinky fingertips
                    let spreadDist = 0; // T·ªïng kho·∫£ng c√°ch gi·ªØa c√°c c·∫∑p ng√≥n g·∫ßn nhau
                    let pairCount = 0;
                    
                    // T√≠nh kho·∫£ng c√°ch gi·ªØa c√°c c·∫∑p ng√≥n li·ªÅn k·ªÅ (index-middle, middle-ring, ring-pinky)
                    for(let i = 0; i < tips.length - 1; i++) {
                        const dist = Math.hypot(lm[tips[i]].x - lm[tips[i+1]].x, lm[tips[i]].y - lm[tips[i+1]].y);
                        spreadDist += dist;
                        pairCount++;
                    }
                    
                    const avgSpread = spreadDist / pairCount; // ƒê·ªô x√≤e ng√≥n trung b√¨nh
                    // Chu·∫©n h√≥a v·ªÅ kho·∫£ng 0.5-1.5 (zoom in khi ng√≥n x√≤e ra, zoom out khi ng√≥n kh√©p l·∫°i)
                    // ƒê·ªô x√≤e th∆∞·ªùng t·ª´ 0.03 (kh√©p) ƒë·∫øn 0.12 (x√≤e r·ªông), map sang zoom 0.5-1.5
                    const normalizedSpread = Math.max(0, Math.min(1, (avgSpread - 0.03) / (0.12 - 0.03)));
                    handZoom = 0.5 + normalizedSpread * 1.0; // Gi·ªõi h·∫°n t·ª´ 0.5 ƒë·∫øn 1.5
                    
                    // T√≠nh kho·∫£ng c√°ch t·ª´ c·ªï tay ƒë·∫øn c√°c ƒë·∫ßu ng√≥n tay (cho gesture detection)
                    const wrist = lm[0]; // C·ªï tay
                    let openDist = 0; 
                    // T·ªïng kho·∫£ng c√°ch t·ª´ c·ªï tay ƒë·∫øn 4 ƒë·∫ßu ng√≥n
                    tips.forEach(i => openDist += Math.hypot(lm[i].x-wrist.x, lm[i].y-wrist.y));
                    const avgDist = openDist / 4; // Kho·∫£ng c√°ch trung b√¨nh
                    
                    // T√≠nh kho·∫£ng c√°ch gi·ªØa ng√≥n c√°i v√† ng√≥n tr·ªè (pinch gesture)
                    const pinchDist = Math.hypot(lm[4].x-lm[8].x, lm[4].y-lm[8].y);

                    // Ph√¢n lo·∫°i c·ª≠ ch·ªâ:
                    if (avgDist < 0.25) { 
                        // N·∫øu kho·∫£ng c√°ch trung b√¨nh nh·ªè => n·∫Øm tay (FIST) => TREE
                        state = 'TREE'; 
                    } else if (pinchDist < 0.05) {
                        // N·∫øu ng√≥n c√°i v√† tr·ªè g·∫ßn nhau => PINCH => PHOTO
                        state = 'PHOTO'; 
                    } else {
                        // Ng∆∞·ª£c l·∫°i => b√†n tay m·ªü (OPEN HAND) => EXPLODE
                        state = 'EXPLODE'; 
                    }
                } else {
                    // Kh√¥ng ph√°t hi·ªán tay => m·∫∑c ƒë·ªãnh v·ªÅ TREE v√† reset zoom
                    state = 'TREE'; 
                    handZoom = 1.0; // Reset zoom v·ªÅ m·∫∑c ƒë·ªãnh
                }
            });

            // Kh·ªüi t·∫°o camera v·ªõi MediaPipe Camera utils
            const cameraUtils = new Camera(video, {
                onFrame: async () => { 
                    // M·ªói frame, g·ª≠i h√¨nh ·∫£nh video v√†o MediaPipe Hands ƒë·ªÉ ph√¢n t√≠ch
                    await hands.send({image: video}); 
                }, 
                width: 320, height: 240 // ƒê·ªô ph√¢n gi·∫£i camera
            });
            cameraUtils.start(); // B·∫Øt ƒë·∫ßu camera
        }

        // X·ª≠ l√Ω s·ª± ki·ªán resize window ƒë·ªÉ ƒëi·ªÅu ch·ªânh camera v√† renderer
        window.addEventListener('resize', () => {
            if(camera) { 
                camera.aspect = window.innerWidth/window.innerHeight; // C·∫≠p nh·∫≠t t·ª∑ l·ªá khung h√¨nh
                camera.updateProjectionMatrix(); // C·∫≠p nh·∫≠t ma tr·∫≠n projection
                renderer.setSize(window.innerWidth, window.innerHeight); // C·∫≠p nh·∫≠t k√≠ch th∆∞·ªõc renderer
            }
        });
    </script>
</body>
</html>